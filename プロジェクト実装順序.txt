【プロジェクト実装順序】

＜最終的なディレクトリ構造＞
プロジェクトルート
├── py_app/         ← Python側のコードを配置
│      ├── ui.py              － UI用コード：PyQt6 を使用したユーザーインターフェースの実装
│      ├── directory_info.py  － 機能用コード：ディレクトリ情報取得（ファイルサイズ、更新日時、アクセス権チェックなど）
│      └── main.py            － エントリーポイント：アプリケーションの起動用コード（exe化時もこのファイルが指定される）
└── rust_lib/      ← Rust側の高速化処理のライブラリを配置

■ 1. Python側の実装（py_app 内に配置）
  
  ① **UI用コード** (例: `py_app/ui.py`)  
     - PyQt6 を使用して、画面表示やディレクトリ選択ダイアログ、結果表示などのユーザーインターフェースを実装

  ② **機能用コード** (例: `py_app/directory_info.py`)  
     - Python の標準ライブラリや外部ライブラリ（例: colorama）を利用し、ディレクトリの情報取得処理を実装  
     - ファイルサイズ計測、更新日時取得、アクセス権チェック等を行う

  ③ **エントリーポイント** (例: `py_app/main.py`)  
     - アプリケーションの実行開始用ファイル  
     - UI 初期化および各機能（UI・処理コード）の組み合わせ、Exe化の際のエントリーポイントとして動作

■ 2. Rust側の実装（rust_lib 内に配置）
  
  ・ Python側で動作確認済みの、処理速度改善が期待できる重い処理部分（例：大規模な再帰探索やディレクトリ情報の集計など）を対象に、Rustで高速処理を実現  
  ・ Rustで作成したライブラリは maturin などを利用して Python 拡張モジュールとしてビルドする  
  ・ Python の機能用コード（py_app/directory_info.py）から、Rustライブラリの処理を呼び出す実装を行う

■ 全体の進行フロー
  
1. まずは、Python単体で、**py_app**ディレクトリ内に【UI用コード】・【機能用コード】・【エントリーポイント】を含む基本システムを作成し、動作確認を実施する  
   （依存ライブラリ：PyQt6、colorama、pytest などを利用）

2. 次に、処理のうちパフォーマンス向上が期待できる部分について、Rust側（**rust_lib**）で高速化ライブラリを作成する  
   （Poetry、maturin、cargo などを連携させ、PythonとRustが連携する仕組みを構築）

3. 最終的に、**py_app**内の機能用コードより Rustライブラリを呼び出し、統合後の動作確認およびテストを実施する

以上の流れで実装を進めていくことで、まずはPython側で全体要件を満たすコードを完成させ、その後でRustにより処理部分の高速化を図る方針となります。